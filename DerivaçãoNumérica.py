# -*- coding: utf-8 -*-
"""
Função restrita à N = 2n + 1 numero de pontos para se calcular a derivada,
sendo n a ordem da derivada requerida
"""

import numpy as np



h = 0.001

# -*- coding: utf-8 -*-
"""TrabalhoDerivadaNum.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hAC6USDca5O6_UkEn79YYEYonYVbYC6_
"""

# -*- coding: utf-8 -*-
"""
O código a seguir define uma função para se calcular as derivadas de uma função
no ponto x0 dado usando n pontos em torno de x0 (com x0 incluso)

A função derivada(orde,func,x0,n) é dividida em duas partes, sendo uma para derivadas de ordem
par (com matrixbcpa e deltapa) e outra para derivadas de ordem impar (com matrixbdip
e deltaip)

Os parametros de entrada são a ordem da derivada (orde), função (func), ponto a ser
calculada a derivada (X0) e numero de pontos com que sera calculada a derivada (n),
sendo n OBRIGATÓRIAMENTE ímpar

o parametro termos (t) também foi utilizado a fim de nos dar quantos termos teremos na array
dos deltas para fins de inicialização e preenchimento das matrizes
"""
#%%imports

import numpy as np

#%% Funções construtoras das matrizes

def matrixbdip(n,h=0.001):
  '''Função construtora da matriz para 'n' pontos das derivadas ímpares.
     Sendo n o número de pontos e h=0.001 o diferencial a ser usado'''
  t = int((n-1)/2)                   #t = numero de deltas para n pontos
  arr = np.zeros((t,t))              #cria a array a ser percorrida pelos loops
  for e in range(1,int(t+1)):        #este loop percorre as linhas (a modificação no range acontece para a função não multiplicar por zero)
      for m in range(1,int(t+1)):    #este loop percorre as colunas
          arr[e-1,m-1] = (2*((e*h)**(2*m-1)))/np.math.factorial((2*m)-1)  #aqui ocorre a definição de cada termo da matriz
  return arr


def matrixbdpa(n,h=0.001):
  '''Função construtora da matriz para 'n' pontos das derivadas pares.
     Sendo n o número de pontos e h=0.001 o diferencial a ser usado'''
  t = int((n-1)/2)                 #t = numero de deltas para n pontos
  arr = np.zeros((t,t))
  for e in range(1,int(t+1)):
      for m in range(1,int(t+1)):
          if m==1:
              arr[e-1,m-1] = 2*e   #TODO: Ajeitar esta matriz com o novo PDF
          else:
              arr[e-1,m-1] = (2*((e*h)**(2*(m-1)))/np.math.factorial(2*(m-1)))
  return arr

#%% Funções construtoras dos deltas

def deltpa(n,func,x0,h=0.001):
  '''Função construtora dos deltas para derivadas de ordem par.
     Recebe 'n' pontos, uma função e um ponto x0 a ser calculado'''
  l = []
  t = (n-1)/2           #Ambas funções delta utilizam o mesmo tamanho de 't' termos
  for e in range(1,int(t+1)):
      dlt = func(x0+(e*h)) + func(x0-(e*h))         #Este loop calcula o delta para cada par simétrico e o insere na lista l
      l.append(dlt)
  l = np.array(l)
  l = l.reshape((int(t),1))    #Aqui a lista é transformada em uma array posteriormente transposta
  return l


def deltip(n,func,x0,h=0.001):
  '''Função construtora dos deltas para derivadas de ordem ímpar.
     Recebe 'n' pontos, uma função e um ponto x0 a ser calculado'''
  l = []
  t = (n-1)/2
  for e in range(1,int(t+1)):
      dlt = func(x0+(e*h)) - func(x0-(e*h))
      l.append(dlt)
  l = np.array(l)
  l = l.reshape((int(t),1))
  return l

#%% Função derivada

def derivada(orde,func,x0,n,h=0.001):
  '''Recebe a ordem da derivada requerida (orde), função a ser derivada (func),
  ponto a ser calculada a derivada (x0) e 'n' pontos a ser utilizados no calculo'''
  if type(orde)!=int and type(orde)!=float:
    return(print('TypeError: a ordem precisa ser int ou float'))                       #Aqui um pequeno controle de erros (nem de perto a forma mais eficiente)
  if type(x0)!=int and type(x0)!=float:
    return(print('TypeError: x0 precisa ser int ou float'))
  if ((n%2)==0) or type(n)!=int:
    return(print('O número n de pontos deve ser OBRIGATORIAMENTE ímpar e inteiro'))
  if ((orde%2)==0):            #Confere se n é ímpar
    dlt = deltpa(n, func, x0)
    mat = matrixbdpa(n)        #Aqui as duas funções anteriormente construídas são chamadas
    #print(mat)
    mat = np.linalg.inv(mat)   #Inversão da matriz de h
    #print(mat)
    der = np.matmul(mat,dlt)   #Multiplicação das matrizes
    #print(der)
    return float(der[int((orde/2)-1)])  #Agora a variavel 'orde' fornecida nos diz qual derivada retornar da array gerada,
  else:                                 #tendo uma regra para o caso par e outra para o caso ímpar.
    dlt = deltip(n, func, x0)           #Como a quantidade de ordens que podemos calcular depende de 't' só podemos calcular
    mat = matrixbdip(n)                 #derivadas na ordem de t == (n-1)/2, por exemplo, precisamos de 'n' pontos == 5 para
    mat = np.linalg.inv(mat)            #se calcular a segunda derivada, pois neste caso t == (5-1)/2 == 2.
    der = np.matmul(mat,dlt)
    return float(der[int((orde-1)/2)])

#%% Funções para teste

def func1(x):
    return 3*x**3

def func2(x):
    return x**5



derivada(3,func1,2,5)

help(derivada)

#%% Funções construtoras das matrizes

def matrixbdip(n,h=0.001):    
    t = int((n-1)/2)
    arr = np.zeros((t,t))
    for e in range(1,int(t+1)):
        for m in range(1,int(t+1)):
            arr[e-1,m-1] = (2*((e*h)**(2*m-1)))/np.math.factorial((2*m)-1)
    return arr
   

def matrixbdpa(n,h=0.001):    
    t = int((n-1)/2)
    arr = np.zeros((t,t))
    for e in range(1,int(t+1)):
        for m in range(1,int(t+1)):
            if m==1:
                arr[e-1,m-1] = 2*e
            else:
                arr[e-1,m-1] = (2*((e*h)**(2*(m-1)))/np.math.factorial(2*(m-1)))
    return arr

#%% Funções construtoras dos deltas

def deltpa(n,func,x0,h=0.001):
    l = []
    t = (n-1)/2
    for e in range(1,int(t+1)):
        dlt = func(x0+(e*h)) + func(x0-(e*h))
        l.append(dlt)
    l = np.array(l)
    return l
        

def deltip(n,func,x0,h=0.001):
    l = []
    t = (n-1)/2
    for e in range(1,int(t+1)):
        dlt = func(x0+(e*h)) - func(x0-(e*h))
        l.append(dlt)
    l = np.array(l)
    return l

        
def func1(x):
    return 3*x**3

def func2(x):
    return x**5
        

def dervad(orde,func,x0,n,h=0.001):
    if ((orde%2)==0):
        dlt = deltpa(n, func, x0)
        mat = matrixbdpa(n)
        print(mat)
        mat = np.linalg.inv(mat)
        print(mat)
        der = np.matmul(mat,dlt)
        print(der)
        return der[int((orde/2)-1)]
    else:
        dlt = deltip(n, func, x0)
        mat = matrixbdip(n)
        mat = np.linalg.inv(mat)
        der = np.matmul(mat,dlt)
        return der[int((orde-1)/2)]
        

dervad(2,func2,2,17)

